# This code contains three procedures: qs that performs quicksort, partition that
# "partitions" the array based on the pivot (end of the input array) and swap,
# which swaps two different locations in memory

# to use the code, we need to initialize an integer array v[n]
# then put the base address of that array in $a0 and the length n in $a1

.data

#smallTable: .word 7,8,1,9,2,6,3,10,4,5
#mediumTable: .word 35,90,26,61,52,6,59,67,36,49,47,41,89,14,16,83,45,28,62,1,39,9,43,42,78,12,70,95,92,60,82,44,53,46,7,23,32,85,18,51,40,75,24,8,76,84,21,20,80,71,56,91,77,66,30,17,4,98,33,3,81,38,5,29,88,31,57,2,10,73,63,64,13,54,79,87,86,55,69,96,19,34,15,74,11,22,65,99,48,58,97,68,50,93,100,25,27,37,94,72
largeTable: .word 277,208,498,372,64,603,537,529,279,218,836,626,175,29,855,155,897,884,116,832,968,641,342,531,715,793,685,135,174,817,453,798,760,470,48,14,50,586,310,624,222,651,224,611,451,128,870,661,863,958,794,406,846,901,966,953,266,710,295,675,549,921,660,520,947,259,307,745,146,488,885,468,781,985,384,356,262,361,487,335,148,78,268,191,246,303,46,467,992,253,23,936,889,849,299,994,26,580,391,213,280,281,644,317,602,298,892,899,733,158,839,801,315,184,694,462,542,378,779,110,818,8,820,104,450,171,264,387,429,238,1000,566,819,552,961,553,118,393,942,96,454,730,722,974,814,716,637,795,878,472,844,102,853,85,729,173,362,666,630,965,380,405,75,265,687,504,728,255,484,613,134,987,699,928,350,152,441,796,804,916,270,693,695,446,735,622,202,676,294,469,390,360,196,678,761,828,633,172,816,370,792,114,938,330,200,964,874,946,392,534,164,739,597,314,704,954,63,327,859,207,521,702,434,486,560,131,856,528,714,86,82,66,684,802,827,199,875,283,258,625,308,972,67,581,221,397,526,319,285,509,247,945,533,56,830,142,416,182,671,615,610,565,18,871,334,482,81,857,933,562,585,194,445,339,290,42,440,822,386,461,37,752,984,614,92,349,373,659,273,417,654,514,803,98,969,679,89,437,161,204,347,851,587,999,336,807,503,197,260,145,364,180,649,750,867,69,478,583,904,831,932,10,909,355,995,727,908,225,898,682,944,479,551,805,394,923,345,634,569,117,376,721,690,511,941,130,188,412,775,439,407,910,510,860,284,501,681,133,978,508,263,1,774,600,17,215,838,383,653,94,983,358,826,282,559,768,926,369,890,674,476,409,638,403,847,54,365,723,952,32,652,719,286,427,864,73,595,532,217,670,241,639,242,235,59,988,43,883,880,949,769,5,689,558,956,198,93,862,523,841,665,567,122,287,743,496,663,311,39,13,115,49,447,564,381,845,572,854,398,550,770,239,237,159,571,959,45,756,986,887,561,248,150,748,119,656,306,764,780,428,757,596,789,650,563,683,982,680,881,205,732,772,998,494,788,190,156,338,799,865,332,448,422,352,708,903,873,389,979,951,323,245,424,420,84,181,9,272,99,577,460,631,425,481,568,220,711,698,990,858,20,737,211,107,456,905,842,543,929,212,203,52,244,707,30,555,609,741,79,153,396,123,593,234,443,960,667,312,840,962,617,726,457,955,126,219,777,829,891,599,328,616,240,400,738,948,809,636,44,527,810,165,578,588,385,502,167,592,21,724,88,431,869,475,61,632,500,742,120,629,35,677,640,642,11,606,333,189,359,228,833,872,886,375,746,519,176,257,604,300,852,758,997,6,411,515,320,751,647,177,401,296,935,582,269,877,712,90,60,76,216,797,696,930,452,937,900,975,896,579,40,36,894,154,725,837,473,608,545,662,249,466,824,374,288,924,278,68,7,316,371,922,432,33,31,366,231,151,271,749,353,87,686,605,160,785,669,967,524,535,782,442,232,505,911,850,346,399,236,627,767,902,101,800,771,108,980,210,140,137,973,506,570,22,193,590,786,163,455,103,77,388,734,601,419,297,267,783,981,201,906,882,250,731,931,700,91,635,879,591,648,744,848,471,438,230,149,811,304,309,612,645,483,183,713,179,4,379,491,292,47,351,187,691,185,692,538,331,861,404,778,950,243,575,111,168,513,598,492,430,324,913,34,340,971,943,516,368,530,927,584,147,426,717,489,919,341,2,812,808,939,229,418,876,95,113,226,525,100,740,329,480,449,996,19,495,620,289,618,576,474,658,357,121,507,573,459,815,754,433,344,753,539,806,74,688,736,554,790,657,458,129,186,765,301,261,907,302,574,321,655,408,367,490,275,477,868,544,132,791,866,70,293,363,112,192,444,322,274,382,41,705,83,38,223,170,697,759,291,27,517,672,835,917,415,787,976,963,435,706,138,912,747,402,940,522,619,703,915,825,24,920,594,914,166,925,343,65,3,71,55,143,843,157,106,463,80,709,62,58,169,776,414,125,977,813,957,326,127,518,97,305,893,436,628,895,664,209,701,540,57,28,53,607,991,536,325,934,337,141,178,784,144,989,485,16,206,124,888,512,413,766,15,348,623,252,643,821,668,276,233,139,465,823,25,762,12,497,556,673,72,105,547,763,162,395,773,254,313,546,755,136,918,493,834,354,548,421,589,621,195,718,464,256,646,227,410,970,541,51,109,499,318,557,377,251,993,720,423,214
.text

      # test quicksort with smallTable
      la $a0, largeTable	# $a0 gets array base address
      li $a1, 0			# $a1 gets start index
      li $a2, 999			# $a2 gets end index
      jal qs
      
      # terminate
      li $v0, 10
      syscall
      

#void quicksort (int v[], int start, int end){
#    if (start < end){
#        int q = partition(v, start, end);
#        quicksort(v, start, q - 1);
#        quicksort(v,q + 1,end);
#    }
#}


# arguments: $a0 = v[], $a1 = start, $a2 = end
# saved variables: $s0 = q, $s1 = v[], $s2 = start, $s3 = end
qs:     
        addi $sp,$sp, -20
        sw $ra, 16($sp)
        sw $s3,12($sp)          # save $s3 on stack
        sw $s2, 8($sp)          # save $s2 on stack
        sw $s1, 4($sp)          # save $s1 on stack
        sw $s0, 0($sp)          # save $s0 on stack
        
	move $s1, $a0		# $s1 = v[]
	move $s2, $a1		# $s2 = start
	move $s3, $a2		# $s3 = end

	# main conditional
	slt $t0, $s2, $s3	# $t0 = (start < end)
	beq $t0, $zero, done	# branch on $t0 == 0
	
	# call partition
	jal partition		# $s0 (q) = partition(...)
        move $s0, $v0
	

	# quicksort(v[], start, q-1)
	addi $t1, $s0, -1	# $t1 = q-1
	move $a0, $s1		# $a0 = v[]
	move $a1, $s2		# $a1 = start
	move $a2, $t1		# $a2 = q-1
	jal qs
	
	# quicksort(v[], q+1, end)
	addi $t1, $s0, 1	# $t1 = q+1
	move $a0, $s1		# $a0 = v[]
	move $a1, $t1		# $a1 = q+1
	move $a2, $s3		# $a2 = end
	jal qs
	
done: 	lw $s0, 0($sp)		# restore $s0 from stack
        lw $s1, 4($sp)          # restore $s1 from stack
        lw $s2, 8($sp)          # restore $s2 from stack
        lw $s3,12($sp)          # restore $s3 from stack
        lw $ra,16($sp)          # restore $ra from stack
        addi $sp,$sp, 20        # restore stack pointer

   	jr $ra
	

#int partition (int v[], int start, int end){
#    int pivot = v[end];
#    int i = start;
#    for (int j = start; j < end; j++ ){
#        if ( <= pivot){
#            swap(v,i,j);
#            i++;
#        }
#    }
#    swap(v, i, end);
#    return i;
#}
      
# arguments: $a0 for v[], $a1 = start, $a2 = end
# saved values: $s0 for pivot, $s1 for i, $s2 for j, $s3 for v[], $s4 for start, $s5 for end
# return value: $v0 for return i
partition:
  	addi $sp,$sp, -28
        sw $ra, 24($sp)
        sw $s5, 20($sp)
        sw $s4, 16($sp)
        sw $s3,12($sp)          # save $s3 on stack
        sw $s2, 8($sp)          # save $s2 on stack
        sw $s1, 4($sp)		# save $s1 on stack
        sw $s0, 0($sp)          # save $s0 on stack        
      
     	sll $t0, $a2, 2		# $s0 (pivot) = v[end]
     	add $t0, $a0, $t0
     	lw $s0, 0($t0)
     	move $s1, $a1		# $s1 (i) = start
	move $s2, $a1		# $s2 (j) = start
	move $s3, $a0		# $s3 (v[]) = v[]
	move $s4, $a1		# $s4 (start) = start
	move $s5, $a2		# $s5 (end) = end
	
	# partition loop
  for:  slt $t1, $s2, $s5	# exit on (j < end) == 0
   	beq $t1, $zero, exit2
   	
   	# if (v[j] <= pivot)
   	sll $t2, $s2, 2		# $t2 = j *4
   	add $t3, $t2, $s3	# $t3 = address of v[j]
   	lw $t3, 0($t3)		# $t3 = v[j]
   	addi $t4, $s0, 1	# $t4 = pivot + 1
   	slt $t5, $t3, $t4	# $t5 = (v[j] < pivot+1)
   	beq $t5, $zero, exit1	# branch on $t5 == 0
   	# swap(v[], i, j]
   	move $a1, $s1		# $a1 = i
   	move $a2, $s2		# $a2 = j
   	jal swap
   	addi $s1, $s1, 1	# i+=1
   	
 exit1: addi $s2, $s2, 1	# j++
	j for
   	
   	# swap(v[], i, end)
 exit2: move $a1, $s1
 	move $a2, $s5
 	jal swap
 	move $v0, $s1
 
 	lw $s0, 0($sp)         # restore $s0 from stack
        lw $s1, 4($sp)         # restore $s1 from stack
        lw $s2, 8($sp)         # restore $s2 from stack
        lw $s3,12($sp)         # restore $s3 from stack
        lw $s4,16($sp)
        lw $s5,20($sp)
        lw $ra,24($sp)         # restore $ra from stack
        addi $sp,$sp, 28       # restore stack pointer
        jr $ra
             
      # swap procedure: $a0 is address of array, $a1 is k, $a2 is j                                       
swap: sll $t1, $a1, 2   # $t1 = k * 4
      add $t1, $a0, $t1 # $t1 = v+(k*4)
                        #   (address of v[k])
      lw $t0, 0($t1)    # $t0 (temp) = v[k]
      sll $t2, $a2, 2	# $t2 = j * 4
      add $t2, $a0, $t2 # $t2 = v+(j*4)
      			#   (address of v[j])
      lw $t3, 0($t2)	# $t3 = v[j]
      sw $t3, 0($t1)    # v[k] = $t3 (v[j])
      sw $t0, 0($t2)    # v[j] = $t0 (temp)
      jr $ra            # return to calling routine

         

